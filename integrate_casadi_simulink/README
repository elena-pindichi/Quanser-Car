In each code 'casadi_simulink_..mpc.m' a mex file is created that is uploaded on the S-function in Simulink. The .c script creates a bridge between Casadi and Simulink.

Explanation line by line:
- In the first part, the weight matrices and the parameters for the problem are defined
- The symbolic vectors for the states and control inputs are defined like:
        "x = SX.sym('x');    
        y = SX.sym('y');    
        theta = SX.sym('theta'); 
        phi = SX.sym('phi');
        states = [x; y; theta; phi];
        n_states = length(states);"
- The nonlinear dynamics are defined in function 'f'
- The reference point is computed
- Standard initialization for direct transcription of an optimal control problem:
        "w = {};     % Optimization variables
        w0 = [];    % Initial guesses
        lbw = [];   % Lower bounds
        ubw = [];   % Upper bounds
        g = {};     % Constraints
        lbg = [];
        ubg = [];
        J = 0;      % Objective function"
- First state is fixed (initial condition):
        "Xk = MX.sym('X0', n_states);
        w = {w{:}, Xk};
        w0 = [w0; zeros(n_states,1)];
        lbw = [lbw; zeros(n_states,1)];
        ubw = [ubw; zeros(n_states,1)];
        Zk = LinOutput(Xk, Delta, l);"
- In the prediction horizon loop, each iteration adds a control input and state transition, it adds tracking and control effort cost for the objecive and it adds the dynamic constraints:
        "% Control variable
            Uk = MX.sym(['U_' num2str(k)], n_controls);
            w = {w{:}, Uk};
            w0 = [w0; 0; 0];
            lbw = [lbw; -1; -1];
            ubw = [ubw;  1;  1];

            % Integrate dynamics
            Fk = F('x0', Xk, 'u', Uk);
            Xk_end = Fk.xf;

            % Cost function: tracking + control effort
            J = J + (Xk - x_ref)' * Q * (Xk - x_ref) + Uk' * R * Uk;

            % New state variable
            Xk = MX.sym(['X_' num2str(k+1)], n_states);
            w = {w{:}, Xk};
            w0 = [w0; zeros(n_states,1)];
            lbw = [lbw; -inf; -inf; -inf; -pi/2];
            ubw = [ubw;  inf; inf; inf; pi/2];

            % Add dynamics constraint
            g = {g{:}, Xk_end - Xk};
            lbg = [lbg; zeros(n_states,1)];
            ubg = [ubg; zeros(n_states,1)];"
- Define and configure the NLP problem:
        "prob = struct('f', J, 'x', vertcat(w{:}), 'g', vertcat(g{:}));
        opts = struct('ipopt', struct('print_level', 0), 'print_time', false);
        solver = nlpsol('solver', 'ipopt', prob, opts);"
- It creates the Symbolic MPC function and solves the NLP symbolically in terms of s0, where the first {} are the inputs of the function and the second {} are the outputs of the function:
        "% Export initial state symbol
        s0 = MX.sym('s0', n_states);
        lbw_sym = MX(lbw);
        ubw_sym = MX(ubw);
        lbw_sym(1:n_states) = s0;
        ubw_sym(1:n_states) = s0;

        % Solve the problem symbolically
        sol_sym = solver('x0', w0, ...
                        'lbx', lbw_sym, ...
                        'ubx', ubw_sym, ...
                        'lbg', lbg, ...
                        'ubg', ubg);

        % Map from initial state to first control input
        mpc_fun = Function('mpc_fun', {s0}, {sol_sym.x(n_states+1:n_states+2)});"
- Saves and compiles the function for fast real-time execution in C/C++:
        "mpc_fun.save('mpc_fun.casadi');
        ...
        mex(...);
        "

The .c script is taken from: https://web.casadi.org/blog/mpc-simulink2/, and it is prewritten by Casadi. It is used for initialization of the ports for both input and output and is linking the .m script code with Simulink.
