% IP 2015
% provide a number of random points through which a bsplines curve has to
% pass
% show both the waypoints, the control points and the bsplines curve

clc 
close all
clear 
st=500;
n=6; 
d=5; 
knot=[0 30]; % from 1 to 10 second
[bs,knot]=bsplines(n,d,knot);
[M,Sd]=bsplineConversionMatrices(n,d,knot);
tt=linspace(min(knot),max(knot)-0.000001,st);

%% generate a collection of way-points
W = [0.5 1.75;
    2.25 2.05;
    3.5 5;
    5 2]'; %waypoint (point to pass)
N=size(W,2)-1;
wpknot=linspace(min(knot),max(knot)-0.0001,N+1);
%% construct an yalmip problem where we impose that the bspline passes through given waypoints at given time instants
clc
%we take equidistant points alongth the bounds of the knot vector
uknot=linspace(min(knot),max(knot)-0.01,n+1); 
%
P = sdpvar(size(W,1),n+1,1);
constraints = [];
objective = 0;

% i compute the cost for the norm of the derivative of z => compute the
% length of the curve
Ptmp=P*M{1};
for i=1:n+2
    for j=1:n+2
        tmp=@(t)(bs{end-1}{i}(t).*bs{end-1}{j}(t));
        objective=objective + (Ptmp(:,i)')*integral(tmp,knot(1),knot(end))*Ptmp(:,j);
    end
end

for i=1:N+1
    tmp=zeros(n+1,1);
    for k=1:n+1
        tmp(k)=bs{end}{k}(wpknot(i));
    end
    constraints=[constraints, W(:,i)==P*tmp];
end
options = sdpsettings('solver','quadprog');

tic
optimize(constraints,objective,options) %solve the otimization problem
toc
P=value(P); %we obtained the control points
%% Compute the function handles giving out the splines
% flat output
x=@(t)(0);
for i=1:length(bs{end})
    x= @(t)(x(t)+P(1,i).*bs{end}{i}(t));
end
y=@(t)(0);
for i=1:length(bs{end})
    y= @(t)(y(t)+P(2,i).*bs{end}{i}(t));
end

% 1st derivative of the flat output
Ptmp=P*M{1};
dot_x=@(t)(0);
for i=1:length(bs{end-1})
    dot_x= @(t)(dot_x(t)+Ptmp(1,i).*bs{end-1}{i}(t));
end
dot_y=@(t)(0);
for i=1:length(bs{end-1})
    dot_y= @(t)(dot_y(t)+Ptmp(2,i).*bs{end-1}{i}(t));
end

% 2nd derivative
Ptmp2=P*M{2};
Ddot_x=@(t)(0);
for i=1:length(bs{end-2})
    Ddot_x= @(t)(Ddot_x(t)+Ptmp2(1,i).*bs{end-2}{i}(t));
end
Ddot_y=@(t)(0);
for i=1:length(bs{end-2})
    Ddot_y= @(t)(Ddot_y(t)+Ptmp2(2,i).*bs{end-2}{i}(t));
end

% 3rd derivative
Ptmp3=P*M{3};
Dddot_x=@(t)(0);
for i=1:length(bs{end-3})
    Dddot_x= @(t)(Dddot_x(t)+Ptmp3(1,i).*bs{end-3}{i}(t));
end

Dddot_y=@(t)(0);
for i=1:length(bs{end-3})
    Dddot_y= @(t)(Dddot_y(t)+Ptmp3(1,i).*bs{end-3}{i}(t));
end

%%


xref = x(tt); dxref = dot_x(tt); ddxref = Ddot_x(tt); dddxref = Dddot_x(tt);
yref = y(tt); dyref = dot_y(tt); ddyref = Ddot_y(tt); dddyref = Dddot_y(tt);


figure
subplot(4,1,1)
plot(tt,xref)
subplot(4,1,2)
plot(tt,dxref)
subplot(4,1,3)
plot(tt,ddxref)
subplot(4,1,4)
plot(tt,dddxref)

%%
figure
hold on
plot(xref, yref,'k')
grid on
plot(P(1,:),P(2,:),'b--')
scatter(P(1,:), P(2,:),'filled','oblue')
scatter(W(1,:), W(2,:),40,'filled','ored')

%%
save('trajectory.mat', 'xref', 'yref', 'dddxref', 'dddyref', 'ddxref','ddyref','dxref','dyref')
