clc, clear, close all;

A_ob = [1 1; 1 -1; -1 -1; -1 1];
b_ob = [1; 1; 1; 1];
O = Polyhedron(A_ob, b_ob);

%% Parameters
N_pred_val = 5;                      % Prediction horizon
Q_val = 20;                          % State weight value
R_val = 1;                           % Input weight value
P_val = 100;                         % Terminal state value
l = 0.256;                           % Length between front and rear
Delta = 0.35;                        % Distance in front of the car

% Define prediction and simulation steps
Ts = 0.3;                            % Sampling time
Npred = N_pred_val;                  % Prediction horizon
Nsim =  1500;                          % Number of simulation steps

% Define system dimensions
dx = 4;                              % State dimensions: x, y, theta
du = 2;                              % Control dimensions: V, omega
dz = 2;

% Initial condition and references
x0 = [0; 2.5; 0; pi/3];              % Initial state [x; y; theta; phi]
z0 = LinOutput(x0, Delta, l);
xref = [5; 0.6; 0; 0];
zref = LinOutput(xref, Delta, l);
u0 = zeros(du, 1);
wref = zeros(du, 1);

%% Constraints
rhat = min(Delta*l*10/sqrt(Delta*Delta + l*l), 1);

% Weights for cost function
Q = Q_val * eye(dz);
R = R_val * eye(du);
P = P_val * Q;
A = eye(dz);
B = Ts * eye(dz);

% ptsU = [];
% for tta = linspace(0,2*pi-1e-4,20)
%     ptsU = [ptsU; [rhat*cos(tta), rhat*sin(tta)]];
% end
% U_approx = Polyhedron('V',ptsU).computeVRep();

%% CasADi optimization
solver = casadi.Opti();

% Define optimization variables
z = solver.variable(dz, Npred + 1);
w = solver.variable(du, Npred);
alpha = solver.variable(dz, Npred + 1);

% Define initial state as a parameter
zinit = solver.parameter(dz, 1);
zref_param = solver.parameter(dz, Npred+1);
wref_param = solver.parameter(du, Npred+1);

H = A_ob;
b = b_ob + 0.15 * ones(4, 1);
% b = b_ob;
M_ob = 10^5;

% Nonlinear dynamics 
f_dynamics = @(x, u) [ u(1) * cos(x(3));
                       u(1) * sin(x(3));
                       u(1)/l * tan(x(4));
                       u(2) ];

% Add initial state constraint
solver.subject_to(z(:, 1) == zinit);

% Add constraints and dynamics for each prediction step
for k = 1 : Npred
    % State update constraint using discretized nonlinear dynamics
    solver.subject_to(z(:, k+1) == A * z(:, k) + B * w(:, k));
    
    % Control input constraints
    solver.subject_to(w(:, k)' * w(:, k) <= rhat);
    % solver.subject_to(U_approx.A*w(:, k) <= U_approx.b);

    solver.subject_to(-H * z(:, k+1) <= -b + M_ob * alpha(:, k+1))
    solver.subject_to(sum(alpha(:, k+1)) <= 2)
end

objective = 0;
for k = 1 : Npred
    objective = objective + (z(:, k) - zref)' * Q * (z(:, k) - zref) + ...
                            (w(:, k) - wref)' * R * (w(:, k) - wref);
end

objective = objective + (z(:, Npred + 1) - zref)' * P * (z(:, Npred + 1) - zref);


%% Define the objective function
% Define the solver
options.ipopt.print_level = 0;
options.ipopt.sb= 'yes';
options.print_time = 0;

solver.minimize(objective)
solver.solver('ipopt', options)

z_ = reshape(zeros(dz, Npred + 1), 1, []);
w_ = reshape(zeros(du, Npred), 1, []);
alpha_ = reshape(ones(2, Npred + 1), 1, []);
option.discrete = [z_, w_, alpha_];
solver.solver('bonmin', option);

% Simulation loop
usim = zeros(du, Nsim);
zsim = zeros(dz, Nsim);
xsim = zeros(dx, Nsim);
wsim = zeros(du, Nsim);

zsim(:, 1) = z0;
xsim(:, 1) = x0;
usim_init = u0;
for i = 1 : Nsim
    solver.set_value(zinit, zsim(:, i))

    sol = solver.solve();
    wsol = sol.value(w);
    M = LinMatrix(xsim(3:4, i), Delta, l);

    usim(:, i) = M^(-1) * wsol(:, 1);
    wsim(:, i) = wsol(:, 1);

    xsim(:, i + 1) = xsim(:, i) + Ts * f_dynamics(xsim(:, i), usim(:, i));
    zsim(:, i + 1) = LinOutput(xsim(:, i+1), Delta, l);
end

figure
scatter(xsim(1, :), xsim(2, :))
grid
title('State space');
xlabel 'x1'
ylabel 'x2'
hold on
plot(O)